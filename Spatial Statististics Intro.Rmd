---
title: "Spatial statistics intro"
output: html_notebook
---

### Simple spatial principles

Task: Generate 200 points uniformly in a rectangle.

`runif(n, a, b)` will generate n random numbers anywhere between a and b

```{r}
n <- 200

xmin <- 0
xmax <- 1
ymin <- 0
ymax <- 2

# Sample from a uniform distribution
x <- runif(n, xmin, xmax)
y <- runif(n, ymin, ymax)
```

```{r}
mapxy <- function(a = NA){
  plot(x, y, asp=a)
  rect(xmin, ymin, xmax, ymax)
}

mapxy(0)
```

### Uniform density point pattern in a circle

We might first try selecting a radius and angle uniformly. But that might produce a cluster at small distances.

Instead, we sample the radius from a non-uniform distribution that scales linearly with distance, so we have fewer points at small radii and more at large radii.

`disc()` function creates a circular window for this task.

**Algorithm**

1.  create `n_points` random numbers uniformly from zero to the radius-squared
2.  Calculate the x y coordinates
    1.  x-values are the values of square root of r_squared times the cosine of angle

    2.  y- values are the square root of r_squared times the sine of angle
3.  plot a disc of `radius` then add the points to the plot

```{r}
library(spatstat)
n_points <- 300
radius <- 10

r_squared <- runif(n_points, 0, radius**2)
angle <- runif(n_points, 0, 2*pi)

x <- sqrt(r_squared) * cos(angle)
y <- sqrt(r_squared) * sin(angle)

plot(disc(radius)); points(x,y)
```

### Quadrant count test for uniformity

Humans tend to see patterns in random arrangements, so we need statistical tests.

It can be used to check if points are completely spatially random, That is they are uniformly random throughout the area of interest.

Quadrat count tests tests are implemented using `quadrat.test()` which takes a planar point pattern, `ppp()` object. "Planar point pattern" is jargon for a set of points in a region of a 2D plane.

```{r}
# list variable that have already been defined
ls.str()

ppxy <- ppp(x = x, y = y, window = disc(radius))

qt <- quadrat.test(ppxy)
plot(qt)
print(qt)
```

### Creating a uniform point pattern with spatstat

A Poison point process creates events according to a Poison distribution with an intensity parameter specifying the expected events per unit area.

The total number of events generated is a single number from a Poisson distribution, so the multiple realizations of the same process can easily have different numbers of events.

In the previous exercise you used a set of 300 events scattered uniformly within a circle. If you repeated the generation of the events again you will still have 300 of them, but in different locations. The dataset of exactly 300 points is from a Poisson point process *conditioned on the total being 300*.

The spatstat package can generate Poisson spatial processes with the `rpoisonp()` function given an intensity and a window that a re not conditioned on the total.

Just as the random number generator functions in R start with an r, most of the random point pattern functions in spatstat start with an "r".

The `area()` function of spatstat will compute the area of a window such as a disc.

```{r}
# create a disc of radius 10
disc10 <- disc(10)

# to generate approximately 500 points in a disc of radius 10, set lambda tp 500 divided by the area of of the disc

lambda <- 500/area(disc10)

# create a point pattern object

ppois <- rpoispp(lambda = lambda, win = disc10)

plot(ppois)
```

### Simulating clustered and inhibitory patterns

Clustered processes - where points occur together more than under a uniform Poisson process, and regular(aka inhibitory) processes where points are more spaced apart than under a uniform intensity Poisson process.

A Thomas process is a clustered pattern where a number of "parent" points, uniformly distributed, create a number of "child" points in their neighborhood. The child points themselves form the pattern.. This is an attractive point pattern and makes sense for modeling things like trees, since new trees will grow near the original tree. Random Thomas point patterns can be generated using `rThomas()`. This takes three numbers that determine the intensity and clustering of the points, and a window object.

Conversely, the points of a Strauss process cause a lowering in the probability of finding another point nearby. The parameters of a Strauss process can be such that it is a "hard-core" process, where no two points can be closer than a set threshold. Creating points from this process involves some clever simulation algorithms. This is a repulsive point pattern, and makes sense for modeling things like territorial animals since the other animals of that species will avoid the territory of a given animal. Random Strauss point patterns can be generated using `rStrauss()`. This takes 3 numbers that determine the intensity and teritory of the points, and a window object. Points generated by a Strauss process are sometimes called regularly spaced

```{r}
# create a disc of radius 10
disc10 <- disc(10)

# generate points from a Thomas process in a disc of radius 10

set.seed(123)
p_cluster <- rThomas(kappa=0.35, scale=1, mu=3, win = disc10)
plot(p_cluster)
```

```{r}
# regular points from a Strauss process
set.seed(123)
p_regular <- rStrauss(beta = 2.9, gamma = 0.025, R = .5, W = disc10)
plot(p_regular)
quadrat.test(p_cluster, alternative="clustered")
quadrat.test(p_regular,, alternative = "regular")
```

### Nearest neighbor distribution

spatstat uses `Gest(ppp)` function to test for this

### Ripley's K function

Stands for Ripley reduced second moment measure

K is the number of expected expected events to be found at a given distance from an event scaled by the intensity. To estimate it for some distance d, visit each event in turn, and count the number of other events in a circle of radius d, take the average, and thats the k of d. Do that for a number of values of d, and you can plot the function. For a completely spatial random process, this gives k of d = pi*d*\*2

This is called Monte carlo
