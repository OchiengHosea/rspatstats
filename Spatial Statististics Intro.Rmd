---
title: "Spatial statistics intro"
output: html_notebook
---

### Simple spatial principles

Task: Generate 200 points uniformly in a rectangle.

`runif(n, a, b)` will generate n random numbers anywhere between a and b

```{r}
n <- 200

xmin <- 0
xmax <- 1
ymin <- 0
ymax <- 2

# Sample from a uniform distribution
x <- runif(n, xmin, xmax)
y <- runif(n, ymin, ymax)
```

```{r}
mapxy <- function(a = NA){
  plot(x, y, asp=a)
  rect(xmin, ymin, xmax, ymax)
}

mapxy(0)
```

### Uniform density point pattern in a circle

We might first try selecting a radius and angle uniformly. But that might produce a cluster at small distances.

Instead, we sample the radius from a non-uniform distribution that scales linearly with distance, so we have fewer points at small radii and more at large radii.

`disc()` function creates a circular window for this task.

**Algorithm**

1.  create `n_points` random numbers uniformly from zero to the radius-squared
2.  Calculate the x y coordinates
    1.  x-values are the values of square root of r_squared times the cosine of angle

    2.  y- values are the square root of r_squared times the sine of angle
3.  plot a disc of `radius` then add the points to the plot

```{r}
library(spatstat)
n_points <- 300
radius <- 10

r_squared <- runif(n_points, 0, radius**2)
angle <- runif(n_points, 0, 2*pi)

x <- sqrt(r_squared) * cos(angle)
y <- sqrt(r_squared) * sin(angle)

plot(disc(radius)); points(x,y)
```

### Quadrant count test for uniformity

Humans tend to see patterns in random arrangements, so we need statistical tests.

It can be used to check if points are completely spatially random, That is they are uniformly random throughout the area of interest.

Quadrat count tests tests are implemented using `quadrat.test()` which takes a planar point pattern, `ppp()` object. "Planar point pattern" is jargon for a set of points in a region of a 2D plane.

```{r}
# list variable that have already been defined
ls.str()

ppxy <- ppp(x = x, y = y, window = disc(radius))

qt <- quadrat.test(ppxy)
plot(qt)
print(qt)
```

### Creating a uniform point pattern with spatstat

A Poison point process creates events according to a Poison distribution with an intensity parameter specifying the expected events per unit area.

The total number of events generated is a single number from a Poisson distribution, so the multiple realizations of the same process can easily have different numbers of events.

In the previous exercise you used a set of 300 events scattered uniformly within a circle. If you repeated the generation of the events again you will still have 300 of them, but in different locations. The dataset of exactly 300 points is from a Poisson point process *conditioned on the total being 300*.

The spatstat package can generate Poisson spatial processes with the `rpoisonp()` function given an intensity and a window that a re not conditioned on the total.

Just as the random number generator functions in R start with an r, most of the random point pattern functions in spatstat start with an "r".

The `area()` function of spatstat will compute the area of a window such as a disc.

```{r}
# create a disc of radius 10
disc10 <- disc(10)

# to generate approximately 500 points in a disc of radius 10, set lambda tp 500 divided by the area of of the disc

lambda <- 500/area(disc10)

# create a point pattern object

ppois <- rpoispp(lambda = lambda, win = disc10)

plot(ppois)
```

### Simulating clustered and inhibitory patterns

Clustered processes - where points occur together more than under a uniform Poisson process, and regular(aka inhibitory) processes where points are more spaced apart than under a uniform intensity Poisson process.

A Thomas process is a clustered pattern where a number of "parent" points, uniformly distributed, create a number of "child" points in their neighborhood. The child points themselves form the pattern.. This is an attractive point pattern and makes sense for modeling things like trees, since new trees will grow near the original tree. Random Thomas point patterns can be generated using `rThomas()`. This takes three numbers that determine the intensity and clustering of the points, and a window object.

Conversely, the points of a Strauss process cause a lowering in the probability of finding another point nearby. The parameters of a Strauss process can be such that it is a "hard-core" process, where no two points can be closer than a set threshold. Creating points from this process involves some clever simulation algorithms. This is a repulsive point pattern, and makes sense for modeling things like territorial animals since the other animals of that species will avoid the territory of a given animal. Random Strauss point patterns can be generated using `rStrauss()`. This takes 3 numbers that determine the intensity and teritory of the points, and a window object. Points generated by a Strauss process are sometimes called regularly spaced

```{r}
# create a disc of radius 10
disc10 <- disc(10)

# generate points from a Thomas process in a disc of radius 10

set.seed(123)
p_cluster <- rThomas(kappa=0.35, scale=1, mu=3, win = disc10)
plot(p_cluster)
```

```{r}
# regular points from a Strauss process
set.seed(123)
p_regular <- rStrauss(beta = 2.9, gamma = 0.025, R = .5, W = disc10)
plot(p_regular)
quadrat.test(p_cluster, alternative="clustered")
quadrat.test(p_regular,, alternative = "regular")
```

### Nearest neighbor distribution

spatstat uses `Gest(ppp)` function to test for this

### Ripley's K function

Stands for Ripley reduced second moment measure

K is the number of expected expected events to be found at a given distance from an event scaled by the intensity. To estimate it for some distance d, visit each event in turn, and count the number of other events in a circle of radius d, take the average, and thats the k of d. Do that for a number of values of d, and you can plot the function. For a completely spatial random process, this gives k of d = pi*d*\*2

This is called Monte carlo

# **Nearest-neighbor distributions**

This is another way of assessing clustering and regularity. It does so by considering each point and how it relates to the other points. One simple feature is the distribution of of distances from each point to its nearest neighbor.

The `nndist()` function in spatstat takes a point pattern and for each point returns the distance to its nearest neighbor. You can then plot the histogram.

Instead of working with the nearest neighbor density, as seen in the histogram, it can be easier to work with the cumulative distribution function, `G(r)` this is the probability of a point having a nearest neighbor within a distance r

For a uniform poisson proecess, G can be computed theoretically, and is `G(r) = 1 - exp( - lambda * pi * r ^ 2)` You can compute G empirically from your data using `Gest()` and so compare with the theoretical value

Events near the edge of the window might have had a nearest nearest neighbor outside the window, and so unobserved. This will make the distance to its observed nearest neighbor larger than expected, biasing the estimate of G. There are several methods for correcting this bias.

Plotting the output from `Gest()` shows the theoretical cumulative distribution and several estimates of the cumulative distribution using different edge corrections. Often these edge corrections are almost indistinguishable. and the lines overlap. The plot can be used as quick exploratory test of complete spatial randomness.

```{r}
# Using ppois and p_regular defined previously

# Calculate nearest neighbor distances for poison
nnd_poisson <- nndist(ppois)

# draw histogram of nearest-neighbor distances
hist(nnd_poison)
# Estimate G(r)
G_poisson <- Gest(ppois)
plot(G_poisson)
```

```{r}
nnd_regular <- nndist(ppois)
plot(nnd_regular)
G_regular <- Gest(p_regular)
plot(G_regular)
```

## Other Point pattern distribution functions

The K-function is defined as the expected number of points within a distance of a point of the process, scaled by the intensity. Like G, this can be computed theoretically for a uniform Poisson process ans is `K(r) = pi *r ^ 2` - the area of a circle of that radius. Deviation from pi \* r \^ 2 can indicate clustering or point inhibition.

Computational estimates of K(r) are done using the `Kest()` function.

As with G calculations, K-function calculations also need edge correctinos. The default edge correlation in `spatstat` is generally the best, but can be slow, so we'll use the `border` correction for the speed here.

Uncertainities on K-function estimates can be assessed by randomly sampling points from a uniform Poisson process in the ares and computing the K-function of the simulated data. Repeat this process 99 times and take the minimum and maximum value of K over each of the distance values.This gives an envelop - If the K-function from the data goes above the top envelope then we have evidence for clustering. If the K-function goes below the envelop then there evidence for an inhibitory process causing the points to be spaced out. Envelopes can be computed using the envelop() function.

The plot method for estimates of `K` uses a formula system where a dot on the left of a formula refers to `K(r)`. So the default plot uses `. ~ r`. You can compare the estimate of `K` to a Poisson process by plotting `. - pi * r ^ 2 ~ r`. If the data was generated by a Poisson process, then the line should be close to zero for all values of `r`.

```{r}
K_poisson <- Kest(ppois, correction="border")
plot(K_poisson, . ~ r)
plot(K_poisson, . - pi * r ^2 ~ r)
```

```{r}
# Compute envelops of K under random locations
K_cluster_env <- envelope(p_cluster, Kest, correction="border")
plot(K_cluster_env, . - pi * r ^ 2 ~ r)
```

```{r}
K_regular_env <- envelope(p_regular, Kest, correction="border")
plot(K_regular_env, . - pi * r ^ 2 ~ r)
```
